# Chapter 2 - Program Flow

Program flow means presenting functions in a proper order. This can mean:

* Conditional flow (if...then)
* Iterative flow (for...each)
* Behaviour flow (onclick)

and... **exception handling**


## Part 1 - Implement flow

`if...else`, `switch...case` and `ternary (?, :)` operators

Must be able to use evaluation operators (`>`, `!=`, etc).

Don't forget about the `==` which doesn't check for data-type equality and `===` which does (as per `!=`/`!==`).

Control statements can be nested.

The logical or is a shortcutting operator.

Switch-case statments - don't forget the `break` and don't use expressions within `case`s

**Arrays** can be created with the `var xyz = new Array([variable|size])` command or with the array literal `[]`.
Arrays are dynamic and will resize appropriately if an out-of-bounds value is set.

We can initialise multi-dimensional arrays by initialising each member of an array to an array as in `arrayVar[0] = new Array(5)`

**Array properties**

* Length: `[1, 2, 3, 4].length === 4` 

**Array Methods**

* concat: `[1, 2, 3].concat([4, 5]) === [1, 2, 3, 4, 5]` -> new array returned
* indexOf - index of a value and starting offset: `"hello".indexOf("l", 0) === 2`
* lastIndexOf - as indexOf, but searches from end: `"hello".lastIndexOf("l", 4) === 3`
* join - joins an array with a seperator: `[1,2,3].join(":") === "1:2:3"`
* reverse - reverses an array: `[1,2,3].reverse() === [3,2,1]` -> **array reversed in-situ**
* sort - sorts an array: `[3,2,5,4,1].sort() === [1,2,3,4,5]` -> **array sorted in-situ**
* slice - returns elements from an array: `['a', 'b', 'c'].slice(0,2) === ['a', 'b']` -> new array returned
* splice - removes elements from an array and optionally replaces with others: `['a', 'b', 'c', 'd'].splice(0, 2, 'e') === ['e', 'c', 'd']` -> **array spliced in-situ**

*Important to remember where array methods affect the array object and where they return new objects*


### Special types of arrays

Queues and stacks can be implemented directly with the `Array` object

* push: `[1, 2].push(3, 4) === [1, 2, 3, 4]` -> **array mutated in-situ**
* pop: `var a = [1, 2, 3], b = a.pop() :: a == [1, 2], b == 3` -> **array mutated in-situ**

Shift and unshift work the same but remove/append to the beginning of arrays:

* shift: `[1, 2, 3].shift() === 1 :: array is now [2, 3]` -> **array mutated in-situ**
* unshift: `[2, 3].unshift(1) === [1, 2, 3]` -> **array mutated in-situ**

This can be used to implement a stack or queue.
Eg.1: Stack (FILO)

```
var stack = new Array();
stack.unshift("First");
stack.unshift("Second");
stack.shift() //"Second"
stack.shift() //"First"
```

Eg.2: Queue (FIFO)
 
```
var queue = new Array();
queue.push("First");
queue.push("Second");
queue.shift() //First
queue.shift() //Second
```

 ### Advanced Array Methods

