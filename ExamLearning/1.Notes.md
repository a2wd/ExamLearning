## Part 1 - HTML5 Semantics

Use `header` and `footer` elements to contain top/bottom content

The `nav` element can be used for navigation

The `hgroup` element can contain headers

`Articles` group independent sections of content like individual blog posts

`Section`s denote different parts of a page and can be grouped under articles

`Aside`s can be used to show relevant information, but not directly related to the current section

`figure` and `figcaption` can be used to show figures and related captions

A `progress` element can have a value and max attributes and is used to show progress
Omitting the value from a progress can indicate an indeterminate progress bar

The `mark` element is used to mark specific content

`div` element is still in use!

html5 can affect both seo and screen readers


## Part 2 - DOM Manipulation

We can access the dom with the following functions of document:

* getElementById
* getElementsByClassName
* getElementsByTagName
* querySelector
* querySelectorAll

The following functions of a dom node

* childNodes
* firstChild
* lastChild
* hasChildNodes

After adding objects, we can remove them with:

* removeChild
* removeNode
* replaceNode //IE Only
* replaceChild //as in node.replaceChild(newChild, oldChild)


### Multimedia

The `<video>` tag allows us to show videos and can have various source parameters
Allowed attributes include autoplay, controls, loop and poster

A reference to the video object in javascript can be used to play, pause and scrub the file

* play()
* pause()
* volume
* currentTime

The `<audio>` element has similar functionality

The `<canvas>` element allows 2d drawings at a pixel-level, the getContext() method of a canvas object
exposes the following methods:

* beginPath
* moveTo
* lineTo
* stroke

There are also curve functions:

* arc
* quadraticCurveTo
* bezierCurveTo

You can call beginPath to start a new line or just closePath to close the last one.

There is also a rect method to draw rectangles and fill/gradient methods to add fills to paths:

* rect()
* fillRect()
* fill()
* createLinearGradient
* createRadialGradient

Further, the stroke style can be set to an `Image()`

Text can be added with the `strokeText` command

SVG can be used to draw and manipulate vector graphics dynamically, it can be simpler than canvas,
though less performant. Possible tags include the following:

* `<rect></rect>`
* `<circle></circle>`
* `<ellipse></ellipse>`
* `<text></text>`

It is also possible to draw regular images via the svg tag.


## Part 3 - Programmatic Styling

It is possible to style elements with code.

Using `el.style.xxx`, where `xxx` could be:

`top`, `left`, `bottom`, `right`, `position`

You can also use CSS for transforms:

* `transform: rotate(90deg);`
* `scale(f)`
* `rotateX(d)`, `rotateY(d)`
* `translate(x, y)`
* `skew(x, y)`

Transformations can be combined. Elements can aslo be hidden by setting the `el.style.display` property to
none (as opposed to inline, block, table, etc). The visibility can also be set to `visible`, `hidden`, `collapse`,
or `inherit`.


## Part 4 - Implementing HTML5 APIs

HTML5 APIs include storage, caching and location services.

WebStorage can save as local and session - local persists but session in (as the name implies), session-based

* `localStorage`
* `sessionStorage`

These are key-value stores (text) and both objects support the following methods:

* `setItem(key, value)`
* `getItem(key)`
* `clear()`
* `key(index)`
* `removeItem(key)`

Object data can be stored by transforming to/from strings with `JSON.stringify` and `JSON.parse`.

AppCache allows for offline storage. The JavaScript api is complemented with a manifest file

The manifest file contains three sections - CACHE, NETWORK and FALLBACK, it must start `CACHE MANIFEST`

The cache section lists all the resources to be made available offline (JPG, CSS, JS, etc)

The network section lists items that can only be found online

The fallback sections lists fallback items to use when the first item is not found

**AppCache** api (via `var appCache = window.applicationCache`):

* .status
    * Uncached
    * Idle
    * Checking
    * Downloading
    * UpdateReady
    * Obsolete
* .swapCache()
* .update()

`update()` is asynchronous, listen to `onupdateready` to know when the download has completed

Events include:

* `onchecking`
* `onnoupdate`
* `ondownloading`
* `onprogress`
* `oncached`
* `onupdateready`
* `onobsolete`
* `onerror`

Most common is to use `appCache.onupdateready()` to do an `appCache.swapCache()`

**GeolocationAPI** can be used to get the user's location

`var geoLocator = window.navigator.gelocation`

This API supports three methods:

* `getCurrentPosition(callback, errCallback, opts)` //current position (store locator)
    * opts:
    * `enableHighAccuracy`
    * `timeout`
    * `maximumAge`
* `watchPosition` //continuously polls for position (directions/maps)
* `clearWatch` //stop polling an object