# Chapter 4 - Troubleshoot & debugging

Tracing & debugging from within Visual Studio

## Part 1 - Preventing/troubleshooting runtime issues

Thrown exceptions are obvious but there are also tools for tracing, logging and diagnostics.

There are many places problems can occur, there are also many tools to diagnose this.

**Performance wizard** allows you to moniter an app's performance. Profiling lets you analyse a running program:

* CPU sampling - lightweight check
* Instrumentation - adds code to all assemblies and times methods & calls
* .net memory allocation (sampling) - check for memory waste, lightweight or with instrumentation
* resource contention data (concurrency) - good for multithreaded apps

A good way to do this is to run a report, make changes and run a new report to compare.

**Visual studio profiler** is a tool that performs a complete trace of calls that happen in an app. It profiles method calls, created types, time spent, etc. There is a *hot path* tool that shows the most intesive flow-route of an app.

**Performance monitor** (`> perfmon`, from the command-line) is a built-in tool for monitoring performance. You can watch details for processes and apps. You can check requests, caches & app errors. You can schedule perfmon.

**Security issues** are usually related to authentication & authorisation. To troubleshoot, check how broad the issue is (users/roles). If for all, could be IIS but if only some, could be the authentication system.

**Tracing, logging & debugging** - logging is saving information. Tracing is analysing the program while running, debugging is analysing from various tools. **NLog** & **log4net** are open source logging tools.

Tracing is built into .net via `System.Diagnostics.TraceListeners` and can be configured via a web.config file. They can write trace info to a DB or file. This is done in code via `Trace.WriteLine("xyz")`. Trace messages can have a level (warn/info/error).

Error logging can be handled via the controller's `OnException`, via a filter or with `HandleErrorAttribute`:

`[HandleError(ExceptionType=typeof(System.IOException), View="FileError")]`

Here, errors can be sent to a new view. You must pass a `HandleErrorInfo` object. This happens without a controller (none is needed).

You can also override `OnException` for the controller or even the base controller, or even in the **Global.asax**.

**Code contracts** help enforce pre-conditions, post-conditions and invariants. You need an extension and code such as: `System.Diagnostics.Contracts.Contract.Requires(varName > 0);`.

Invariants are managed in seperate classes decorated with `[ContractInvariantMethod]` and `System.Diagnostics.Contract.Invariant()`. These checks can only be violated during private method calls.

Post-conditions are similar, with `System.Diagnostics.Contracts.Contract.Ensures()`.

**Health monitoring** logs all application events - startup/shutdown, security events, errors, and more. It can be set up in the Web.config, via `<healthMonitoring>`.

It has a number of sections:

* bufferModes - how long events are buffered
* providers - what to use to write the event
* profiles - the minimum number of instances after which to log an event
* rules - each event to be logged is set up a provider in rules
* eventMapping - set up event mapping to providers.


## Part 2 - Exception handling

Data layer -> Business layer -> UI layer

In a multi-layer application, exeptions can happen in different layers but can't be managed from one layer - the business layer might need to handle data-layer exceptions but it will never know about UI layer errors so they must be handled by the UI layer.

The application needs to decide at each layer what do with exceptions and how best to handle them.

**Error pages** are built as part of the error-handling process. A model can be passed in with relevant information about the error.

The `Global.asax` method `Application_Error` can be used to set up a custom controller to handle errors in the application.

Per regular ASP.net, you can also set the error handling via the **web.config** (`customErrors` node).

**First chance exceptions** refer to all errors before they are handled and they can be monitored during development to avoid them happening in production. Turn on in VS via the *Thrown* checkbox of the *Common Language Runtime Exceptions* setting in the exceptions dialog.

By looking at first chance exceptions you can speed up an application by removing errors that would otherwise be handled and waste resource in the process.

You can also capture first chance exceptions on production by adding a `Application.CurrentDomain.FirstChanceException` handler in `Global.asax`.

**Errors in the first chance exception handler cause a stack overflow!**


## Part 3 - Test a web app

Changing one part of an app might cause subtle bugs in another part - this can be remedied through unit testing.

**Unit testing** can be used as a *predictor* of functionality as per TDD or as a *reinforcement* of functionality when making new releases.

**It is good to have a test project for each assembly in a solution**

**Structure**: it is good to have a test class for each model, controller or other code-file in the solution

Test methods have the following structure:

```
[TestMethod]
public void Add_Test()
{
 CalculationManager manager = new CalculationManager ();
 Assert.IsTrue(manager.Add(2, 2).Equals(4), "2 + 2 = 4");
 Assert.IsTrue(manager.Add(2, 2.5).Equals(4.5), "2 + 2.5 = 4.5");
 try { manager.Add(DateTime.Now, 2.5);}
 catch (Exception ex){ Assert.IsInstanceOfType(ex,
typeof(InvalidCastException), "Today + 2 = oops");}
}
```

Unit tests should each test one aspect of functionality and do so thoroughly. They should not need dependencies to run.

**Integration tests** are used for this instead - such as DB testing, try each of the CRUD methods on a DB object for instance. You can also use the application's DB calls, but the directly query the database to check that the data has been stored.

### Mocks/fakes

**Shim** - A small bit of code to intercept a call to an assembly/method and return a pre-defined object instead. For assemblies outside the solution

**Stub** - replaces a class with a limited subset of that class for the test. For assemblies inside the solution.

Fakes assemblies can be added to the references of a unit-test project. An example of using a shim to override DateTime.Now:

```
using (ShimsContext.Create())
{
 // insert the delegate that returns call for DateTime.Now
 System.Fakes.ShimDateTime.NowGet = () => new DateTime(2010, 1, 1);
 MethodThatUsesDateTimeNow();
}
```

You can replace any .net method with a shim.

With shims, you must preface the shim with Fakes.Shim per the above. With stubs, your interface will be prefixed Fakes.Stub.

**Web tests** help you check for how the application behaves under high load or with program flow (as opposed to unit test that just check the functionality of methods).

You can choose to add a *web test and load project* to the solution. Test flows can be set up and recorded to .webtest files, there are three main uses:

1. Constant load tests to check performance against a constant number of users.
2. Step loading - to add users incrementally.
3. Goal based load-test to try and max out CPU or memory

You can also distribute the testing across multiple machines.

You can plan for:

* Smoke tests - to check the app runs
* Stress tests - could last hours
* Performance tests - for responsiveness
* Capacity planning - can be used with expexted visitor numbers and target CPU usage to plan for server capacity.
 

