# Chapter 4 - Troubleshoot & debugging

Tracing & debugging from within Visual Studio

## Part 1 - Preventing/troubleshooting runtime issues

Thrown exceptions are obvious but there are also tools for tracing, logging and diagnostics.

There are many places problems can occur, there are also many tools to diagnose this.

**Performance wizard** allows you to moniter an app's performance. Profiling lets you analyse a running program:

* CPU sampling - lightweight check
* Instrumentation - adds code to all assemblies and times methods & calls
* .net memory allocation (sampling) - check for memory waste, lightweight or with instrumentation
* resource contention data (concurrency) - good for multithreaded apps

A good way to do this is to run a report, make changes and run a new report to compare.

**Visual studio profiler** is a tool that performs a complete trace of calls that happen in an app. It profiles method calls, created types, time spent, etc. There is a *hot path* tool that shows the most intesive flow-route of an app.

**Performance monitor** (`> perfmon`, from the command-line) is a built-in tool for monitoring performance. You can watch details for processes and apps. You can check requests, caches & app errors. You can schedule perfmon.

**Security issues** are usually related to authentication & authorisation. To troubleshoot, check how broad the issue is (users/roles). If for all, could be IIS but if only some, could be the authentication system.

**Tracing, logging & debugging** - logging is saving information. Tracing is analysing the program while running, debugging is analysing from various tools. **NLog** & **log4net** are open source logging tools.

Tracing is built into .net via `System.Diagnostics.TraceListeners` and can be configured via a web.config file. They can write trace info to a DB or file. This is done in code via `Trace.WriteLine("xyz")`. Trace messages can have a level (warn/info/error).

Error logging can be handled via the controller's `OnException`, via a filter or with `HandleErrorAttribute`:

`[HandleError(ExceptionType=typeof(System.IOException), View="FileError")]`

Here, errors can be sent to a new view. You must pass a `HandleErrorInfo` object. This happens without a controller (none is needed).

You can also override `OnException` for the controller or even the base controller, or even in the **Global.asax**.

**Code contracts** help enforce pre-conditions, post-conditions and invariants. You need an extension and code such as: `System.Diagnostics.Contracts.Contract.Requires(varName > 0);`.

Invariants are managed in seperate classes decorated with `[ContractInvariantMethod]` and `System.Diagnostics.Contract.Invariant()`. These checks can only be violated during private method calls.

Post-conditions are similar, with `System.Diagnostics.Contracts.Contract.Ensures()`.

**Health monitoring** logs all application events - startup/shutdown, security events, errors, and more. It can be set up in the Web.config, via `<healthMonitoring>`.

It has a number of sections:

* bufferModes - how long events are buffered
* providers - what to use to write the event
* profiles - the minimum number of instances after which to log an event
* rules - each event to be logged is set up a provider in rules
* eventMapping - set up event mapping to providers.


## Part 2 - Exception handling

Data layer -> Business layer -> UI layer

In a multi-layer application, exeptions can happen in different layers but can't be managed from one layer - the business layer might need to handle data-layer exceptions but it will never know about UI layer errors so they must be handled by the UI layer.

The application needs to decide at each layer what do with exceptions and how best to handle them.

**Error pages** are built as part of the error-handling process. A model can be passed in with relevant information about the error.

The `Global.asax` method `Application_Error` can be used to set up a custom controller to handle errors in the application.

Per regular ASP.net, you can also set the error handling via the **web.config** (`customErrors` node).

**First chance exceptions** refer to all errors before they are handled and they can be monitored during development to avoid them happening in production. Turn on in VS via the *Thrown* checkbox of the *Common Language Runtime Exceptions* setting in the exceptions dialog.

By looking at first chance exceptions you can speed up an application by removing errors that would otherwise be handled and waste resource in the process.

You can also capture first chance exceptions on production by adding a `Application.CurrentDomain.FirstChanceException` handler in `Global.asax`.

**Errors in the first chance exception handler cause a stack overflow!**

