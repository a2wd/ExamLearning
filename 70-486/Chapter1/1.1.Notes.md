# Chapter 1 - Design the application architecture

## Part 1 - Plan the application layers

An application is one or more related features, these are built up in *layers* of code.

MVC (model-view-controller) is about seperating different bits of the architecture - SoC (seperation of concerns).

* **Model** is business logic
* **View** is what a user sees
* **Controller** is the code that manages the two

### Planning data access

Data is key to designing an app. You can access it with an ORM (object relational mapper) or by rolling your own code.

The three main methods of developing the database are:

* **Model-first**, by using visual modelling & design tools
* **Code-first**, by building POCO (plain old CLR objects) from which a generator builds the db
* **Database-first**, by directly writing a schema. Best for updates/updgrades

If using entity framework to manage the DB access, extra code needs to be added - either in the controller or as an extra layer.

The **repository pattern** is a fancy way of talking about this abstraction and is a way of improving unit testing by further seperating the DB from the code.

### Planning seperation of concerns

Seperate parts of an application that have different purposes - the data models from the presentation of the data.

MVC has the added complexity of JavaScript run client-side.

**Loose coupling** means parts can operate independently of each other, leading to more stable code.

ASP.NET MVC has a lot of conventions that come into play - folder, file & class/method naming schemes (ie, SomethingController C# file).

### Models

Handles the business logic, manages data access, located in the `models` folder (or, a seperate assembly, for easier sharing)

Often made in the controller and passed to the view.

There are three main type of model:

* **Domain** model, in the case of an entity framework Model
* **View** model, in the case of all the data being sent to a view
* **Input** model, in the case of the user's input, as modelled

Model binders can collate this information into the model


### Controllers

Controllers handle the business logic of an application.

Users interact with the application by calling URL paths which are mapped to actions.

The controller takes the request, calls the relevant model and binds the data to response.

The user's interactions are based on **Action methods** which map methods to URLs/interactions

 Consider the data model and the user's work when building the controllers.

 Controllers have **actions** and **action results**

 The **actions** are the methods called by a URL, the **actionresults** are the views passed back to the client

 **actionResults** can also return JSON or binary data.

 Some actions may be taken automatically by the system like a JS `timeout` that calls a method

 The `Global.asax` file has a routing table.
 
 The default format is `controller/action/id`, which sends id as a param to action method of the controllerController

 Actions can be *decorated* with attributes such as `[HttpOnly]` or `[ValidateInput]`.

**Asynchronous** methods can be made with the **Task** framework from `System.Threading.Tasks`.

Asynchronous controllers are useful for tasks which require long-running IO or network activities (CPU intensive things don't make that much of a difference).

To make an async method, mark it as `async` and return a `Task<ActionResult>` as per:

```
public async Task<ActionResult> ExampleFunc()
{
	ViewBag.SyncOrAsync = "Asynchronous";

	...
	network intensive operation
	...

	return PartialView("partialViewName", results);
}
```

## Views

Views get data in a `ViewBag` (a `ViewDataDictionary`).

There are **strongly-typed views**, **ViewModels**, **Partial Views**, **Master/layout pages**, **Scaffold templates**

A layout may have common design inside which a view sits, optionally with one or more nested partial views.

**Razor** is the default view engine, with the **@** delimiter.

Anything other than basic coding should be done in a controller.

The view engine can be extended and overridden.

**Inline code should only be about displaying information, not modifying/processing it**

Client side vs. server side processing: where does the work take place? What needs to change? Think about performance and latency. Eg. Client side validation to decrease server calls and improve performance for all users.

**Scaling** can be done:

* Horizontally (with lots of servers), or
* Vertically (with higher-power servers)

Scaling horizontally requires you to think about how shared resources are accessed and about caching plans.

Scaling vertically requires more thought about the efficiency of the app, and has a single point of failure.

Database scalability is another decision - hosting different DBs on different machines and using different types of DB

