# Chapter 5 - Design and implement security

## Part 1 - Configure authentication

Authentication is about confirming the user is who they say they are. In ASP.NET MVC, IIS and the .NET framework both work together for authentication.

The are two types of authentication:

* challenge-based
	* Basic
	* Digest
	* Windows
	* Client certificate mapping
	* IIS client certificate mapping
* login-redirection-based 
	* Forms authentication

There is also:

* Anonymous

To use anything other than anonymous in IIS, you need to **configure server roles** > *security* and also *enable them in IIS*.

In a request, a `HttpModule` carries out the authentication and adds the user info to the `HttpContext` as well as the `System.Threading.Thread.CurrentPrincipal`.

If the two go out of sync you can update them manually (set `.CurrentPrincipal` to `System.Web.HttpContext.Current.User`).

`System.Security.Principal.IPrincipal` - the user role
`System.Security.Principal.IIdentity` - the user name/isAuthenticated

There are implementations of this in .net:

**WindowsIdentity/WindowsPrincipal** (AD), **FormsIdentity/GenericPrincipal** and **GenericIdentity/GenericPrincipal**.

With **Anonymous** authentication, the user isn't authenticated but a default anonymous user must be set up to provide site visitors with the appropriate access rights for files - otherwise an unauthorised token is returned. This can be set from config fils, IIS or with the **AppCmd.exe** CLI.

With **Basic authentication**, username/passwords are only base-64 encoded. This is a wraper around windows accounts - the user will need to have access. A domain can be provided by the user of set by default otherwise they will be authorised against the local store.

With **Digest**, the same process is followed but the server and client exchange unique hash values rather than plaintext passwords.

With **Forms** authentication, the process doesn't require windows accounts, so users can be managed by the developer such as via a SQL database.

The server code must call `FormsAuthentication.SetAuthCookie`. The following code shows this:

```
[ControllerAction]
public void Authenticate(string uname, string pass)
{
 User user = dbContext.Users.First (x=>x.UserName.Equals(uname();
 if (user != null && user.Password.Equals(EncryptHash(pass))
 {
FormsAuthentication.SetAuthCookie(uname, false);
RedirectToAction("Main", "DashBoard");
 }
 // unable to login
 RenderView("Index", new LoginViewData
 {
ErrorMessage = "Invalid credentials."
 });
}
```

You can also call `FormsAuthentication.ClearAuthCookie` to unset/logout the user.

**Windows authentication** allows for single-sign-on.

With Windows Authentication, you can also use **ASP.NET Impersonation Authentication** to receive the same permissions from the filesystem as the user who authenticated (as opposed to the server's permissions).

This can be turned on in the web.config (`system.web > identity` node).

**Certificate** based auth require an SSL server certificate as well as a client certificate. CC auth assumes active directory but IIS CC Auth also allows use of the local store.

You can also roll your own custom auth, either by using the IPrincipal and IIdentity providers or by doing it all yourself.

In MVC, it's better to add the `[Authorize]` attribute to required ActionMethods than to use the web.config, though you can also just do the authorisation in the action itself.

You could also add a custom filter to perform additional authentication and add it to a controller, an action or globally with a `filters.Add()` call.

If you added it globally, that could prevent access to the login page - you can add an `AllowAnonymous` attribute instead to create a whitelist.

If you set up anonymous access but add `Authorize` filters, actions will be un view-able.

With forms authentication, you can secure the cookie with HTTPS - by adding `RequireHttps` to a controller/action or globally with `filters.Add(new RequireHttpsAttribte())`.

**MVC** is stateless so user information (when using forms-authentication) is stored in a cookie. This is called the `FormsAuthenticationTicket` object:

```
FormsAuthenticationTicket authTicket = new FormsAuthenticationTicket(
1,
userName,
DateTime.Now,
DateTime.Now.AddDays(90),
createPersistentCookie, // a Boolean indicating whether a cookie
// should be created on the user's machine
String.Join(";",rolesArr) //user's roles
);
// add cookie to response stream
string encTicket = FormsAuthentication.Encrypt(authTicket);
System.Web.HttpCookie authCookie = new System.Web.HttpCookie(FormsAuthentication.
 FormsCookieName, encTicket);
System.Web.HttpContext.Current.Response.Cookies.Add(authCookie);
```

You can send encrypted data in a cookie, or better yet you could send the session id instead, holding information like roles on the server.

### Configuring membership providers.

Since ASP 2.0, membership was configured in files, but MVC 4 introduced `SimpleMembership`, with `SimpleRoleProvider` and `SimpleMembershipProvider`. Before, you had a key-value store but with `SimpleMembership`, you can choose column names for the Usernames/Passwords, etc.

`WebSecurity` is a wrapper for the SimpleMembership. It has a few methods:

* Login
* ResetPassword
* CreateAccount
* ChangePassword

**Custom membership providers** shouldn't go into the controllers as they may be cached. Instead you can extend the app by implementing a class that inherits `AuthorizeAttribute`

To override a FormsAuthentication class, there's the  `FormsAuthentication` which handles the initial cookie and then `FormsAuthenticationModule` which handles further requests. SetAuthCookie relies on the `<machineKey>` in the `Machine.config` which should all be the same in a server farm.

You could also use the same backend with multiple frontends if you set up different `ApplicationName`s and store similar user names with a unique `ApplicationName`.


## Part 2 - Configure & apply authorisation