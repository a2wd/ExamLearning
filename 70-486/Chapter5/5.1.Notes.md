# Chapter 5 - Design and implement security

## Part 1 - Configure authentication

Authentication is about confirming the user is who they say they are. In ASP.NET MVC, IIS and the .NET framework both work together for authentication.

The are two types of authentication:

* challenge-based
	* Basic
	* Digest
	* Windows
	* Client certificate mapping
	* IIS client certificate mapping
* login-redirection-based 
	* Forms authentication

There is also:

* Anonymous

To use anything other than anonymous in IIS, you need to **configure server roles** > *security* and also *enable them in IIS*.

In a request, a `HttpModule` carries out the authentication and adds the user info to the `HttpContext` as well as the `System.Threading.Thread.CurrentPrincipal`.

If the two go out of sync you can update them manually (set `.CurrentPrincipal` to `System.Web.HttpContext.Current.User`).

`System.Security.Principal.IPrincipal` - the user role
`System.Security.Principal.IIdentity` - the user name/isAuthenticated

There are implementations of this in .net:

**WindowsIdentity/WindowsPrincipal** (AD), **FormsIdentity/GenericPrincipal** and **GenericIdentity/GenericPrincipal**.

With **Anonymous** authentication, the user isn't authenticated but a default anonymous user must be set up to provide site visitors with the appropriate access rights for files - otherwise an unauthorised token is returned. This can be set from config fils, IIS or with the **AppCmd.exe** CLI.

With **Basic authentication**, username/passwords are only base-64 encoded. This is a wraper around windows accounts - the user will need to have access. A domain can be provided by the user of set by default otherwise they will be authorised against the local store.

With **Digest**, the same process is followed but the server and client exchange unique hash values rather than plaintext passwords.

With **Forms** authentication, the process doesn't require windows accounts, so users can be managed by the developer such as via a SQL database.

The server code must call `FormsAuthentication.SetAuthCookie`. The following code shows this:

```
[ControllerAction]
public void Authenticate(string uname, string pass)
{
 User user = dbContext.Users.First (x=>x.UserName.Equals(uname();
 if (user != null && user.Password.Equals(EncryptHash(pass))
 {
FormsAuthentication.SetAuthCookie(uname, false);
RedirectToAction("Main", "DashBoard");
 }
 // unable to login
 RenderView("Index", new LoginViewData
 {
ErrorMessage = "Invalid credentials."
 });
}
```

You can also call `FormsAuthentication.ClearAuthCookie` to unset/logout the user.

**Windows authentication** allows for single-sign-on.

With Windows Authentication, you can also use **ASP.NET Impersonation Authentication** to receive the same permissions from the filesystem as the user who authenticated (as opposed to the server's permissions).

This can be turned on in the web.config (`system.web > identity` node).

**Certificate** based auth require an SSL server certificate as well as a client certificate. CC auth assumes active directory but IIS CC Auth also allows use of the local store.

You can also roll your own custom auth, either by using the IPrincipal and IIdentity providers or by doing it all yourself.

In MVC, it's better to add the `[Authorize]` attribute to required ActionMethods than to use the web.config, though you can also just do the authorisation in the action itself.

You could also add a custom filter to perform additional authentication and add it to a controller, an action or globally with a `filters.Add()` call.

If you added it globally, that could prevent access to the login page - you can add an `AllowAnonymous` attribute instead to create a whitelist.

If you set up anonymous access but add `Authorize` filters, actions will be un view-able.

With forms authentication, you can secure the cookie with HTTPS - by adding `RequireHttps` to a controller/action or globally with `filters.Add(new RequireHttpsAttribte())`.

**MVC** is stateless so user information (when using forms-authentication) is stored in a cookie. This is called the `FormsAuthenticationTicket` object:

```
FormsAuthenticationTicket authTicket = new FormsAuthenticationTicket(
1,
userName,
DateTime.Now,
DateTime.Now.AddDays(90),
createPersistentCookie, // a Boolean indicating whether a cookie
// should be created on the user's machine
String.Join(";",rolesArr) //user's roles
);
// add cookie to response stream
string encTicket = FormsAuthentication.Encrypt(authTicket);
System.Web.HttpCookie authCookie = new System.Web.HttpCookie(FormsAuthentication.
 FormsCookieName, encTicket);
System.Web.HttpContext.Current.Response.Cookies.Add(authCookie);
```

You can send encrypted data in a cookie, or better yet you could send the session id instead, holding information like roles on the server.

### Configuring membership providers.

Since ASP 2.0, membership was configured in files, but MVC 4 introduced `SimpleMembership`, with `SimpleRoleProvider` and `SimpleMembershipProvider`. Before, you had a key-value store but with `SimpleMembership`, you can choose column names for the Usernames/Passwords, etc.

`WebSecurity` is a wrapper for the SimpleMembership. It has a few methods:

* Login
* ResetPassword
* CreateAccount
* ChangePassword

**Custom membership providers** shouldn't go into the controllers as they may be cached. Instead you can extend the app by implementing a class that inherits `AuthorizeAttribute`

To override a FormsAuthentication class, there's the  `FormsAuthentication` which handles the initial cookie and then `FormsAuthenticationModule` which handles further requests. SetAuthCookie relies on the `<machineKey>` in the `Machine.config` which should all be the same in a server farm.

You could also use the same backend with multiple frontends if you set up different `ApplicationName`s and store similar user names with a unique `ApplicationName`.


## Part 2 - Configure & apply authorisation

Authorisation is about letting people have do CRUD actions. Roles are useful becasuse you can set up the required permissions and then add/remove users to those roles.

**Roles** vary depending on the system being used - in AD, they are preset by the system. In forms-based auth, they are stored in a SQL table. There is a web configuration tool for when using forms-auth with the ASP.net membership provider (though not with `SimpleMembership`).

ASP doesn't provide a built-in way to make roles; they need to be added manually (with and interface and the Roles API). You can set roles in the **web.config** which allows you to change them without changing the app (unless using `SimpleMemberhipProvider`, in which case you need the `InitializeDatabaseConnection` method).

**Programmatically** authorizing based on roles is possible, such as with filters `[Authorize(Roles="Administrator,CanEditOrder")]`.

If you need to programmatically assign roles, you can also query dynamically:

```
string[] userRolesArray = Roles.GetRolesForUser();
string[] rolesForContentArray = DbContext.GetRolesForViewFromDb(thisViewName);
if (userRolesArray.Intersect(RolesForContentArray).Count >  0)
{
	// The user is authorized
}
```

You can also take a hybrid approach and have fixed roles, assigned programatically.

Errors are handled differently - `AuthorizeAttribute` sends the user to a login screen but `WebSecurity.ReqireRole` sends the user to a 401.

You can implement your own **roles provider** by inheriting *RoleProvider* and writing the appropriate classes. The implementation must be thread safe. It's more likely to need to create a new role provider for new functionality than just overriding.

**WCF (Windows Communication Framework)** requires in-app authentication. You can do this with app-specific credentials or pass along the user's credentials. Usually WCF has the same authorisation as your app but here your app would be the client. You can also make the calls in back-end or front-end code.

You can do this in C# with a `new WCFServiceClient()` object. You can also pass on windows auth. from the client but must have ASP.net impersonation turned on for this.


## Part 3 - Claims based authentication across federated identity stores

Like OAuth or OpenID, it's about accepting third party log-ins.

The Windows Azure framework for this is ACS, Access Control Service (Windows Azure Active Directory Access Control) integrates with Windows Identity Framework (WIF) and supports Google/Yahoo, etc. You can use it for Active Directory Federation Services (ADFS) and OAuth, various web tokens and has a web-based management portal.

ACS requires seven steps:

1. Client request to app
2. App forwards user to ACS
3. ACS forwards user to chosen identity provider
4. User authenticates with identity provider, gets token
5. User forwards token to ACS
6. ACS checks token, consolidates into new token and sends client+token to app
7. App checks token came from ACS, validates token, then sends back data

This process is in `Microsoft.Web.WebPages.OAuth`, specifically `VerifyAuthentication` and `Login`. An example would be:

```
[AllowAnonymous]
public ActionResult ExternalLoginCallback(string returnUrl)
{
    // send the request for a login to the ACS
    AuthenticationResult result = OAuthWebSecurity.VerifyAuthentication(
        Url.Action("ExternalLoginCallback", new { ReturnUrl = returnUrl }));
    if (!result.IsSuccessful)
    {
        return RedirectToAction("ExternalLoginFailure");
    }
    // check for the access token
    if (result.ExtraData.Keys.Contains("accesstoken"))
    {
        Session["accesstoken "] = result.ExtraData["accesstoken"];
    }
    // login to the local application using information from provider
    if (OAuthWebSecurity.Login(
        result.Provider,
        result.ProviderUserId,
        createPersistentCookie: false))
    {
        return RedirectToLocal(returnUrl);
    }
    if (User.Identity.IsAuthenticated)
    {
        // If the current user is logged in add the new account
        OAuthWebSecurity.CreateOrUpdateAccount(
            result.Provider,
            result.ProviderUserId,
            User.Identity.Name);
        return RedirectToLocal(returnUrl);
    }
else {
        // User is new, ask for their desired membership name
        string loginData = OAuthWebSecurity.SerializeProviderUserId(
            result.Provider,
            result.ProviderUserId);
        ViewBag.ProviderDisplayName =
            OAuthWebSecurity.GetOAuthClientData(result.Provider).DisplayName;
        ViewBag.ReturnUrl = returnUrl;
        return View("ExternalLoginConfirmation", new RegisterExternalLoginModel
        {
            UserName = result.UserName,
            ExternalLoginData = loginData,
            FullName = result.ExtraData["name"],
            Link = result.ExtraData["link"]
}); }
}
```

This method of auth. means storing the same number of users in DB including a seperate reference to the identity provider (in case an email isn't unique to just that provider).

**WIF, Windows Identity Framework** for custom tokens: abstractions for WS-Trust & WS-Fedetation protocols. Identity providers also now support claims. Different tokens are supported or new ones can be made. Custom tokens must inherit `SecurityToken`.

The handler for a custom token must derive `SecurityTokenHandler` and implement `CanReadToken` after which it needs to be validated in `CustomTokenClass.ValidateThisSignature()`.

To use custom tokens, you must also add web.config entries:

```
<configSections>
    <!-- Registers the microsoft.IdentityModel configuration section -->
    <section name="microsoft.identityModel"
       type="Microsoft.IdentityModel.Configuration.MicrosoftIdentityModelSection,
       Microsoft.IdentityModel, Version=3.5.0.0" />
  </configSections>
  <microsoft.identityModel>
    <service>
      <securityTokenHandlers>
        <remove
             type="Microsoft.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler,
             Microsoft.IdentityModel" />
        <add type="MyCustomToken.CustomUserNamePasswordValidatorSecurityTokenHandler,
             MyCustomToken" />
      </securityTokenHandlers>
    </service>
  </microsoft.identityModel>
```

This is for different federators like a legacy mainframe, but when creating a custom federator you could still implement it with the traditional tokens.

**SAML and SWT tokens** (security assertion markup language/simple web token) - SAML is XML based, SWT is simpler and encrypted symmetrically. JWT represents claims, with a JWS (json web signature), optionally encrypted (JWE, json web encryption).

WIF has a number of handlers which can be extended:

*  EncryptedSecurityTokenHandler
*  KerberosSecurityTokenHandler
*  MembershipUserNameSecurityTokenHandler
*  RsaSecurityTokenHandler
*  Saml2SecurityTokenHandler
*  SamlSecurityTokenHandler
*  SessionSecurityTokenHandler
*  UserNameSecurityTokenHandler
*  WindowsUserNameSecurityTokenHandler
*  X509SecurityTokenHandler

SAML tokens are usually set up in a config file. You can extend and override via `Saml2SecurityTokenHandler`, creating a new class inheriting from `SecurityTokenHandler`, overriding the required methods (CanReadToken, ReadToken, CanWriteToken, WriteToken, CanValidateToken, ValidateToken) and add the new type into the `<securityTokenHandlers>` node of the web.config file.

