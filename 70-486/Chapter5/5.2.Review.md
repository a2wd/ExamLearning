# Review

Chapter 5 - Design and implement security

## Part 1

Configure authentication

### Thought experiment

1. To authenticate an app against an existing database, you could use the forms authentication and set up the authentication to use the pre-existing database

**Create a custom authentication provider and implement IIdentity and IPrincipal**

2. If the existing database is never grandfathered, this is a good solution as no changes are necessary.

**Correct**

3. If the existing database is in an old application, then support could be ended for it and as standards change, it may become obsolete.

**Correct**

### Quiz

* 1.B Digest credentials are hashed and checked against the local store or domain **//Correct**
* 2.A FormsAuthentication.SetAuthCookie allows you to set the credentials cookie **//Correct**
* 3.D You would use allow-anonymous to create an ASP whitelist **A/D or authorise attribute**
* 4.B/C/D IIdentity, IPrincipal & SqlMembershipProvider need to be implemented for a custom auth. **B/C, not SqlMembershipProvider**
* 5.A/B/C/D/E WebSecurity provides access to CRUD for accounts. **//A/B/C/D - E deleteAccount is not valid**


## Part 2

Configure & apply authorisation

### Thought experiment

1. The advantages of many roles are for more fine-grained access permissions and the lack of need to change the application at a later date as it is more likely that every eventuality will have been thought of.

**Correct**

2. To mitigate the maintenance challenge, you could store the roles in active directory, or another third-party (or custom) roles system that is not tied to the application and can thus be updated independently.

**Use groups or templates**

### Quiz

* 1.B `[Authorize(Roles="Admin")]` allows you to programatically check for a user in a role in a controller **//Correct**
* 2.B/C `GetRolesForUser` and `IsUserInRole` allow you to check for a user in a role **//Correct**
* 3.B/D To create a custom roles provider, you must use `SimpleRoleProvider` and provide a config file entry. **A/C you would need to create a custom provider for MySQL and for a different DB design**


## Part 3

Claims based authentication

### Thought experiment

1. When authenticating users through a third party claims-based system, the types of claims you might want to receive include a customer ID or identifying information such as a customer name/email and company.

**Correct**

2. Implementing Azure ACS would reduce the amount of work needed as many steps are taken care of by the framework.

**Correct**

### Quiz

* 1.D in an ACS system, ACS receives user claims and issues the final token to the app **//Correct**
* 2.B to use a custom token in WIF, you must override `SecurityTokenHandler` **//Correct**
* 3.A/B WIF adds the concept of a claim to the IIdentity and IPrincipal **//Correct**


## Part 4

Maintain data integrity

### Thought experiment

1. The primary advantage of encrypting all user data makes it harder for it to be exposed if hacked.

**Correct**

2. Disadvantages of this include that hashing and salting is unecessary when you could just encrypt based on a random key, also the efficacy of this method has not been peer reviewed and the keys being symmetric are vulnerable to hackers.

**Correct, but it would also make access harder for your application**

3. In this instance, the advantages probably don't outweigh the disadvantages since if the database is hacked, it is reasonable to assume that the server is also hacked and thus the keys would be exposed.

**Correct**

### Quiz

* 1.C `CryptoStream` handles the data encryption **//Correct**
* 2.B/C/D digital signatures are used for authentication, nonrepudiation and authorisation **//Correct**
* 3.A You can encrypt a web.config section with the aspnet_regis executable **//Correct**

## Part 5

Implement a secure site with ASP.net

### Thought experiment

1. The advantages of storing a salt in a seperate database are that it would make cracking the password much harder and would require more knowledge and work

**Correct**

2. Storing the salts in the same databse, however, would mean less processing power required on the server to validate a password and also a quicker validation time.

**Correct**

3. It is not generally considered to be of sufficient value to store the salts in a seperate database, considering the processing tradeoffs.

**Correct**

### Quiz

* 1.B/C A cerificate authority validates the company and signs the certificate **//Correct**
* 2.C/D AntiXSS takes an accepted-list approach and enhances globalisation capabilities **//B/C/D - also it's more performant**
* 3.B/C/D parameterising data and filtering out keywords can block SQL injection attacks. **B/C filtering out is no good**