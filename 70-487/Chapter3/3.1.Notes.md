# Chapter 3 - Designing and implementing WCF services

## Part 1 - Create a WCF service

WCF is about distributed and SOA (Service-oriented architecture) apps.

### SOA concepts

* Service - a component that can do one or more tasks
* Service definition - WCF uses contracts, the service definition is a contract defining a service feature.
* Binding - the transport, encoding & protocol.
* Serialisation - transforming the data for transport

Service oriented architecture has:

* Explicit boundaries
* Autonomous services
* Based around schemas & contracts, not classes/DLLs
* Service compatibility is based on policy

### Creating contracts

There are different types of contract:

* ServiceContract attribute - a service
* OperationContract attribute - operation, part of a service
* DataContract attribute - serialisable datatype
* FaultContract attribute - platform-agnostic exception information

WCF can be self-hosted and can be libraries or apps. You could build one with a regular class library and add references, but the WCF template does this for you.

The project template is created with references to `System.ServiceModel` and `System.Runtime.Serialization` and an `App.config`. There is a IService interface definition and the Service.cs class itself.

The contract aspect of services is implemented with `Interfaces`. Generally the interface not the implementing class is decorated with `ServiceContract`.

The types that are being used can be decorated with `DataContract` to ensure they're serialisable.

Methods not defined in the interface (and thus contract) are possible but won't be available to the client, the same if methods are defined but not decorated with `OperationContract`.

**If the eam features a custom data type, it must be serialisable with the `DataContract` attribute**

### Endpoints

To use a service you must know the endpoint

* A - address - the URI
* B - binding - the hosting mechanism
* C - contract - the interface

There are lots of different bindings types:

BasicHttpBinding
WSHttpBinding
WSFederationHttpBinding
NetTcpBinding
NetNamedPipeBinding

The bindings have different options for security (nonde, message, transport, mixed), session (none, reliable session, transport) and transactions (y/n).

### WCF processing pipeline

In between the client & service is a pipeline.

A proxy class is created for the client to enable interaction with the service's methods.

The request is serialised and sent via the protocol specified in the binding; client data is deserialised for the service to consume it.

To serialise data it's good to use platform agnostic primitive datatypes like strings, bytes, integers.

### DataContract

In WCF the default is DataContract (serialisations are opt-in) - the predecessor used XmlSerialier (serialisations are opt-out).

The `KnownTypeAttribute` can indicate that a type be serialised.

A type won't be serialised if the item is derived from the contract, is an interface or if it is transmitted as an object.

You can use the `KnownType` to specify how it can be serialised.

Generally polymorphism should be avoided in SOA.

You need to decorate any complex type returned by a service with the `DataContract` attribute. You can specify the class name and a namespace (in case of conflicting names).

### DataMember

DataMember is used to decorate a serialisable property. There are a few options:

* EmitDefaultValue - default to true. Ie, null for reference types.
* Name - different name for clients to consume
* IsRequired - prop must have a value if true
* Order - the order of serialisation
* TypeId - if defined in a derived class, returns a unique identifier

**EmitDefaultValue might be in a question on size of serialised message**

### EnumMember

To decorate the possible values of an enum.

* Name - returns the name of the enum
* Value - returns the value of the enum
* BuiltInTypeKind - returns the kind of this type
* Documentation - gets/sets a documentation object

### FaultContracts

Technology/platform-agnostic way of dealing with failures. To present information safe for consumers of the service. 

You can define the types of fault that will be thrown in the `FaultContract` and throw a generic `FaultException<T>`.

The `FautReason` can be used to give extra information about the fault (ie, SOAP 1.1 or SOAP 1.2 and other codes like VersionMismatch, MustUnderstand).

The binding may affect the type of faultcodes used as BasicHttpBinding supports SOAP 1.1 but WsHttpBinding uses SOAP 1.2

You can also use the MessageFault class for a granular message/error handling such as with a hack attempt on a username/password.

There are various overloads for `FaultException`.

### Implementing inspectors

We can extend the WCF processing pipeline using:

* Parameter inspection
* Message formatting
* Message inspecting

A parameter inspector could be used for client side validation to save a server round-trip.

This is done with the `IParameterInspector` interface, with the `BeforeCall()` and `AfterCall()` methods. You can add a reference to this class client-side to the Behaviours collection of the Operations property of the proxy class:

`ProxyInstance.Endpoint.Contract.Operations[0].Behaviours.Add(new UserNameInspector());`

Here, the UserNameInspector class must inherit `Attribute` and `IOperationBehaviour`

### Implementing Message inspectors

Used to inspect a message before/after processing. Using the `IDispatchMessageInspector` interface and the `AfterReceiveRequest()` or `BeforeSendReply()` methods.

By using the `MessageInspector` you can add/remove/edit the behaviour with configuration:

```
<extensions>
 <behaviorExtensions>
 <add name="clientSample" type="Samples.WCF.Services.ClientInspector, ClientHost, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"/>
 </behaviorExtensions>
</extensions>
```

The `IClientMessageInspector` interface has the `AfterReceiveReply()` and `BeforeSendRequest()` methods and similar configuration options. The class can be created client side, server side or both.

## Part 2 - Configure WCF services by using configuration settings.

All aspects can be set in code or in configuration files, but files are better as they can be changed without recompiling, or even access to the source.

An app can be a **service** a **client** or both

You can use the wizard to specify the configuration file and you can set a number of elements:

* A new service element `<system.ServiceModel> <services>`
* The services and corresponding contracts
* The service comms mode (HTTP, TCP, MSMQ, etc).
* The interoperability mode (basic, advanced [adv w/Simplex or Duplex comms])

As an example:

```
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
 <system.serviceModel>
 <services>
 <service name="Samples.WCF.Services.TestService">
 <endpoint address=http://www.williamgryan.mobi/samples/487
 binding="wsDualHttpBinding" bindingConfiguration="" name="DualHttp"
 contract="Samples.WCF.Services.ITestService" />
 </service>
 </services>
 </system.serviceModel>
</configuration>
```

### Service metadata

Metadata endpoints are prefixed *mex* for *metadata-exchange*.

* mexHttpBinding
* mexHttpsBinding
* mexNamedPipeBinding
* mexMsmqBinding

An exmple of using a binding would be to put the following in a `<service>` section:

```
<endpoint binding="mexHttpBinding" bindingConfiguration="" name="Mex" contract="IMetadataExchange" />
```

You can also specify **EndpointBehaviours** and **ServiceBehaviours** such as:

* Client credentials
* Transaction batching
* The data contract serialiserw

These would go in the System.serviceModel section of the config:

```
 <behaviors>
 <serviceBehaviors>
 <behavior name="Debug">
 <serviceDebug />
 </behavior>
 </serviceBehaviors>
 </behaviors> <services>
 <service behaviorConfiguration="Debug" name="Samples.WCF.Services.TestService">
```The service behaviourConfiguration is specified.THere are also protocol mappings to map specific schemes (http) to a binding (BasicHttpBinding).### Configuring service endpointsThis can be done in a similar way with the WCF service configuration editor or in the config file directly.As per service behaviours, they are also added and referenced in the same way:```<endpointBehaviors>
 <behavior name="wsHttpBehaviorSample">
 <clientCredentials />
 </behavior>
 </endpointBehavior><endpoint address=http://www.williamgryan.mobi/samples/487  behaviorConfiguration="wsHttpBehaviorSample" binding="wsHttpBinding" bindingConfiguration="" name="WsHttp" contract="Samples.WCF.Services.ITestService" />```### Configuring bindingsYou can configure the binding in the editor or in code.Adding a protocolMapping section will specify the default binding configuration if if one was not identified.