# Chapter 5 - Deploying web application services

## Part 1 - Design a deployment strategy

Deployment can be anything from a file copy to a PowerShell scripted process.

### XCopy

File transfers can happen over FTP or RDP. The dos tool xcopy was used for this and now file transfers are often called xcopy.

`xcopy /I /S /E <source> <dest>`

* /I - copy a folder
* /S - subdirectories
* /E - empty folders
* /d - only newer files

You then need to set up IIS. When copying files, placing a `App_offline.html` file will cause visitors to see a friendly message rather than errors.

The waitChangeNotification sets a timeout (seconds) to wait before recycling: `<httpRuntime waitChangeNotification="5" />`

Visual studio has a **copy website tool** which can be used to automate this and only transfer needed files. It also handles App_offline.html.

There is also a **Publish Website** tool for *website projects* and a **Publish option** for *web application projects*.

**IIS Install package**s can be created with **Web deploy** and scripted with PowerShell, they can include GAC (global assembly cache) files, registry settings etc.

### Continuous deployment / integration

The CI can be done with a **Build Server** that builds on check-in or with a rolling build of a few check-ins.

You can then test with unit tests, integration tests and end-to-end tests.

TFS is on-prem, Team Foundation Services is in the cloud. You can auto-deploy from a repo in Azure.

You can also run MSBuild to make an Azure package from TFS on-prem:

`MSBuild /target:Publish /p:PublishDir=\\myserver\drops\`

You can write the *build definition* file to call PowerShell scripts to deploy directly to Azure.

### Web farms

You can scale out to many servers easily with Azure. This is opposed to scaling up or getting better hardware for one server.

A web farm also needs a load balancer like **Windows Network Load Balancing**.

You need to configure one server and copy that to others (including certificates, IIS extensions, etc). Azure does this automatically.

Session state needs to work differently too:

* InProc - session stored in-memory on individual machines (not for web farms)
* StateServer - session stored on a server
* SqlServer - session stored in a DB
* OffMode (disables all sessions)

Some load balancers have *session affinity* so each session stays on the same machine.

Alternatives to session include storing data in the query string.


## Part 2 - Choosing a deployment strategy for a Windows Azure web app

### In place upgrade & VIP Swap

With Azure you can *delete & redeploy*, do an *in place update* or a *vip swap*.

Deleting and redploying is necessary to change the number/ports of endpoints. Same for firewall changes, certificate updates or migrations to a new OS.

Other changes can be done with a swap or in-place update.

### Configuring an upgrade domain

You can do this via the portal or in Visual Studio.

There are update domains and fault domains. The ServiceDefinition config file lets you define how many from a default of 5 up to a maximum of 20 upgrade domains.

In place upgrades run one by one for one domain then the next. This can lead to errors if changing DB schemas.

### VIP Swap

**Virtual IP Swap** - Swap slots let you deploy to staging and switch the slot to production later.

Set up a deployment slot, click the swap button in the portal. The VIP swap is good if there are changes to the service definition.

### Creating/configuring input & internal endpoints

There are two types of endpoint:

* Input endpoint - HTTP/HTTPS/TCP connections for external services
* Internal endpoint - HTTP/TCP connections for internal services

You can have 25 of each. They are declared in the `ServiceDefinition.csdef` file:

```
<?xml version="1.0" encoding="utf-8"?>
<ServiceDefinition name="WindowsAzure1" xmlns="http://schemas.microsoft.com/ ServiceHosting/2008/10/ServiceDefinition" schemaVersion="2013-03.2.0">
<WebRole name="MyWebApp" vmsize="Small">
	<Sites>
		<Site name="Web">
			<Bindings>
				<Binding name="Endpoint1" endpointName="Endpoint1" />
			</Bindings>
		</Site>
	</Sites>
	<Endpoints>
		<InputEndpoint name="Endpoint1" protocol="http" port="80" />
		<!-- The following can be added later -->
		<InputEndpoint name="WorkerRoleInput" port="8080" protocol="http" localPort="8080"/>
	</Endpoints>
	<Imports>
		<Import moduleName="Diagnostics" />
	</Imports>
</WebRole>
<WorkerRole name="MyWorkerRole" vmsize="Small">
	<Imports>
		<Import moduleName="Diagnostics" />
	</Imports>
</WorkerRole>
</ServiceDefinition>
```

The above is for one cloud project with two roles - one worker, one web.
ad balancer forwards port 8080 requests to the worker role.

You can now use the following code to listen in the worker role:

```
public override void Run()
{
	HttpListener listener = new HttpListener();
	listener.Prefixes.Add("http://*:8081/");
	listener.Start();

	while (true)
	{
		HttpListenerContext context = listener.GetContext();
		HttpListenerRequest request = context.Request;
		HttpListenerResponse response = context.Response;
		string responseString = "<HTML><BODY> Hello world!</BODY></HTML>";
		byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);
		response.ContentLength64 = buffer.Length;
		System.IO.Stream output = response.OutputStream;
		output.Write(buffer, 0, buffer.Length);
		output.Close();
	}
}
```

The input endpoints can be configured via the `InstanceInputEndpoint` setting in the visual studio configuration window. It's also called a direct port:

```
<InstanceInputEndpoint name="Endpoint2" localPort="1000" protocol="tcp">
	<AllocatePublicPortFrom>
		<FixedPortRange min="10016" max="10020"/>
	</AllocatePublicPortFrom>
</InstanceInputEndpoint>
```

### OS Configurations

The `ServiceDefinition.csdef` file also lets you specify OS configs. You can set everything from the OS version to the connection strings and more:

```
<?xml version="1.0" encoding="utf-8"?>
<ServiceConfiguration serviceName="WindowsAzure1" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration"
osFamily="3" osVersion="*" schemaVersion="2013-03.2.0">
<Role name="MyWebApp">
	<Instances count="1" />
	<ConfigurationSettings>
		<Setting name="Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString" value="UseDevelopmentStorage=true" />
	</ConfigurationSettings>
</Role>
<Role name="MyWorkerRole">
	<Instances count="1" />
	<ConfigurationSettings>
		<Setting name="Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString" value="UseDevelopmentStorage=true" />
	</ConfigurationSettings>
</Role>
</ServiceConfiguration>
```

Here, osFamily sets the windows server version and osVersion sets the major/minor release version to latest with *.