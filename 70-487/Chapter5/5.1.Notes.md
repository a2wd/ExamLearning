# Chapter 5 - Deploying web application services

## Part 1 - Design a deployment strategy

Deployment can be anything from a file copy to a PowerShell scripted process.

### XCopy

File transfers can happen over FTP or RDP. The dos tool xcopy was used for this and now file transfers are often called xcopy.

`xcopy /I /S /E <source> <dest>`

* /I - copy a folder
* /S - subdirectories
* /E - empty folders
* /d - only newer files

You then need to set up IIS. When copying files, placing a `App_offline.html` file will cause visitors to see a friendly message rather than errors.

The waitChangeNotification sets a timeout (seconds) to wait before recycling: `<httpRuntime waitChangeNotification="5" />`

Visual studio has a **copy website tool** which can be used to automate this and only transfer needed files. It also handles App_offline.html.

There is also a **Publish Website** tool for *website projects* and a **Publish option** for *web application projects*.

**IIS Install package**s can be created with **Web deploy** and scripted with PowerShell, they can include GAC (global assembly cache) files, registry settings etc.

### Continuous deployment / integration

The CI can be done with a **Build Server** that builds on check-in or with a rolling build of a few check-ins.

You can then test with unit tests, integration tests and end-to-end tests.

TFS is on-prem, Team Foundation Services is in the cloud. You can auto-deploy from a repo in Azure.

You can also run MSBuild to make an Azure package from TFS on-prem:

`MSBuild /target:Publish /p:PublishDir=\\myserver\drops\`

You can write the *build definition* file to call PowerShell scripts to deploy directly to Azure.

### Web farms

You can scale out to many servers easily with Azure. This is opposed to scaling up or getting better hardware for one server.

A web farm also needs a load balancer like **Windows Network Load Balancing**.

You need to configure one server and copy that to others (including certificates, IIS extensions, etc). Azure does this automatically.

Session state needs to work differently too:

* InProc - session stored in-memory on individual machines (not for web farms)
* StateServer - session stored on a server
* SqlServer - session stored in a DB
* OffMode (disables all sessions)

Some load balancers have *session affinity* so each session stays on the same machine.

Alternatives to session include storing data in the query string.

