# Chapter 4 - Creating and consuming web API based services

## Part 1 - Design a Web API

WebAPI is HTTP so a lot of configuration is already taken care of.

### Choosing appropriate methods

It's important to use the right REST verb and the correct status code.

Methods:

* Delete - delete
* Get - read
* Put - update
* Post - create
* Head - retrieves the message headers
* Patch - update (partial message only identifiers and modified fields are sent)
* Options - request for info about comms options available

With **HttpGet**, you may have a scheme such as the following and you can check inside the method for whether the item exists and throw a HttpResponseException with HttpStatusCode of NotFound if necessary.

`/api/something/key` or `/api/something?attribute=val`

**HttpDelete**: it's a good idea to prefix delete operations for clarity. This could return 200 (OK), 202 (Accepted, pending) or 204 (No response - a void return on the method will cause this).

**HttpPost** is always used to create new items. HTTP 1.1 states you return 201 (created) when creating items but this doesn't happen automatically. You can return a value from a POST method to indicate success.

For example:

```
[HttpPost]
public HttpResponseMessage PostAccount(Account account)
{
 HttpResponseMessage response = Request.CreateResponse<Account>(HttpStatusCode.Created, account);
 string newUri = Url.Link("NamedApi", new { accountId = account.AccountId });
 response.Headers.Location = new Uri(newUri);
 return response;
}
```

**HttpPut** is straightforward, methods can be labelled with `[HttpPut]` and should have Put in the name.

**It's a good idea to put simple parameters in the request route but save complex types for the request body**

>> For the exam, the CRUD **update** is represented by the WebAPI **put**.

### Defining resources with actions

In VisualStudio, you would use the WebAPI project. It is usually a good idea to build the model first.

The model is a regular .net class with public properties. The default constructor must be public.

The controller must inherit `ApiController` and defines the actions/action methods that can be used.

For instance you may have an `AccountController` with a `GetAccounts` class and a `SearchAccounts` class. That respectively return JSON or XML serialised data of the relevant accounts.

When a request doesn't match available data you can return a HttpResponseException with a HttpStatusCode or a HttpResponseMessage.

**Browser functionality/support**: when testing, different browsers will have different behaviour due to sending different headers. For instance, in IE10: `Accept: text/html, application/xhtml+xml, */*`

### Routing

The routing is defined in the routing table which implements `System.Web.Http.Routing.IHttpRouting`.

```
config.Routes.MapHttpRoute(
 name: "DefaultApi",
 routeTemplate: "api/{controller}/{id}",
 defaults: new { id = RouteParameter.Optional }
 );
```

The default WebAPI routing works for **GET**, **POST**, **PUT** and **DELETE**. If using convention, you don't need to decorate a method (ie, with `[HttpPut]`).

**Use `System.Web.Http` for `ApiController` and `System.Web.Mvc` for `MvcController`**.

The `[AcceptVerbs(string[] verbs)]` atrribute allows you to specify multiple verbs for a method.

**ActionName**: you can specify the action in the route: `routeTemplate: "api/{controller}/{action}/{id}"` or in an attribute: `[ActionName("myAction")]`.

You can also specify public methods (which would automatically be exposed as actions) to not be actions with the `[NonAction]` attribute.

**Response formats** depend on the browser's sent headers, though this can be specified if using Ajax. You can serialise the data with different formats using a `MediaTypeFormatter` or `BufferedMediaTypeFormatter`.

### Planning for async

WebAPI calls run on a thread each - so too many queues and long running operations can cause a server slow/melt-down.

__Async calls are a good fit for IO-bound tasks__ (if CPU-bound, say by intensive processing tasks, then there is little to no benefit).

The folllowing illustrates converting a sync method to async:

```
public string Get()
{
 WebClient webClient = new WebClient();
 string result = webClient.DownloadString("http://microsoft.com");
 return result;
}

public async Task<string> Get()
{
 WebClient webClient = new WebClient();
 string result = await webClient.DownloadStringTaskAsync("http://microsoft.com");

 return result;
}
```

## Part 2 - Implement a WebAPI