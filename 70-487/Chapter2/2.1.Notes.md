# Chapter 2 - Querying and manipulating data with EntityFramework

## Part 1 - Query/Manipulate data with EF

### Using DbContext

`DbContext` replaces the older `ObjectContext` from EF 5+

#### Querying

You can use LINQ and reference the context:

```
var query = (from acct in context.Accounts
            where acct.AccountAlias == "Primary"
            select acct).FirstOrDefault();
```

#### Updating

You can update an item then call `int context.SaveChanges(item[s])` (returns no. of items updated), or make a new item and Add/Attach it.

Adding an item adds it with an empty `EntityState`, but attaching could have `Unchanged` if added after changes to that item.

If you attach before further changes, the `Update` method would get called.


#### Deleting

First call set to set the type of query to remove, then call remove & `SaveChanges`:

`context.Set<Account>().Remove(query);`

### Deferred execution

A good solution to impedance mismatch (the difference between relational SQL and OOP C#) is an ORM. EF is Microsoft's ORM.

There might be too much data in a DB to read - LINQ & EF allow *deferred execution*, essentially lazy-loading of data.

For instance, no data will be called until the foreach loop:

```
var query = from acct in Context.Accounts
            where acct.AccountAlias == "Primary"
            select acct;

foreach (var currentAccount in query)
{
    Console.WriteLine("Current Account Alias: {0}", currentAccount.AccountAlias);
}
```

While here, no data is retrieved:

```
EntityFrameworkSamplesEntities context = new EntityFrameworkSamplesEntities();
var query = (from acct in context.Accounts
            where acct.AccountAlias == "Primary"
            select acct).Count();
```

### Implementing lazy/eager loading

* In lazy loading, data is called when needed. Ie, on a join, one table is called but the second can be deferred until required.
* In eager loading, everything is called immediately, similar to a DataAdapter or DataSet.
* You can use explicit loading via the `Load` extension to execute queires individually.

Lazy loading can lead to more round-trips so better when you don't know how much data is needed.

Explicit loading requires fewer trips so better when you know exactly the data required.

You can turn on/off via the designer properties window (`Lazy Loading Enabled`), which modifies the `.edmx` file. You can also do it via code and the `context.Configuration.LazyLoadingEnabled` boolean flag.

You can use `.FirstOrDefault()` to bypass deferred execution. There are also other greedy ops:

* ToList, ToArray, ToDictionary
* An aggregate function (Average, Count, Max).

If calling both the aggregate function and looping, just call tolist/array/dictionary first then Count on that to avoid two DB roundtrips.

### Compiled queries

You can improve performance with a cached **compiled query** (done automatically since .net 4.5), but can be done manually for improved performance.

```
static readonly Func<MyObjectContext, string, Person>  compiledQuery = CompiledQuery.Compile<MyObjectContext, string, Person>(
        (ctx, email) => (from p in ctx.People
        where p.EmailAddress == email
        select p).FirstOrDefault());

Person p = compiledQuery.Invoke(context, "foo@bar");
```

### Entity SQL

Entity SQL is string based and similar to SQL, but with knowledge of the model.

```
var queryString =   "SELECT VALUE p " +
                    "FROM MyEntities.People AS p " +
                    "WHERE p.FirstName='John'";

ObjectQuery<Person> people = context.CreateQuery<Person>(queryString);
```

You can also use the Entity SQL to stream raw data.


## Part 2 - Query & manipulate data using data provider for E.F.

**Very likely to appear on the exam**

### Querying w/Connection, DataReader & Command

`System.Data.EntityClient` is for EF data access, a connection & command is required for reading with a variable to hold the info.

#### EntityConnection

There are various connections - `SqlConnection`, `OracleConnection`, etc. Here `EntityConnection` can be used with no params or a connection string: `new EntityConnection(connectionString);`.

This can be built from another connection provider (ie, SqlConnection), and requires a MetaData property to be set.

#### EntityCommand

Works the same as other commands. Has:

* `CreateParameter` - for parameterised queries
* `ExecuteNonQuery` - executes CUD command, has `ExecuteNonQueryAsync`
* `ExecuteReader` - executes query, returns `EntityDataReader`
* `ExecuteScalar` - as above, for scalars, also: `ExecuteScalarAsync`

You can also use an **EntityTransaction** (or just the regular `System.Transactions.TransactionScope`).

### Sync & async ops

Async ops work the same as synchronous ones and have a `CancellationToken` property.

### Managing transactions

Per E.F., there are:

* `DbTransaction` - part of `IDbTransaction`, store the returned `DbTransaction` for `Commit` and `Rollback` methods
* `TransactionScope` - Call `Complete()`, then `SaveChanges()` and on failure, nothing happens - no need to rollback.


## Part 3 - Query data by using LINQ to Entities

LINQ and EF complement each other.